---
title: "[리트코드] 1. Two Sum"
excerpt: "현재 개발자들에게 핫한 리트코드 문제를 풀어봅시다."

categories:
  - leetcode
tags:
  - [algorithm, leetcode]

permalink: /leetcode/2025-07-07-LeetCode-1.-Two-Sum/

toc: true
toc_sticky: true

date: 2025-07-07
last_modified_at: 2025-07-07
---

## 🦥 본문

백준 서버가 터졌습니다.  
당분간은 복구될 기미가 보이지 않아, 다른 사이트에서 공부해야겠네요.  
그래서 LeetCode(리트코드) 사이트를 소개합니다.  
최근 개발자들이 알고리즘 공부에 많이 사용하는 사이트죠.  
영어로 되어있긴 하지만, 요즘 많은 코딩테스트 문제들이 영어로 출제되는 걸 생각하면  
여기서 대비하는 게 도움될 것입니다.  
다만, 여기는 알고리즘 분류는 지원하지 않기 때문에  
1번 문제부터 순차적으로 풀어보도록 하겠습니다.  
자, 그럼 문제 만나보시죠.  
(참고로, 로그인을 해야 문제를 볼 수 있으니 회원가입이 필요합니다!)  
  
[Two Sum - LeetCode](https://leetcode.com/problems/two-sum/)  
  
요약하자면, 덧셈으로 target 값을 만들 수 있는 두 수의 index를 출력해야 하네요.  
그런데, 스켈레톤 코드가 당황스럽습니다.  
  
<script src="https://gist.github.com/redjo99/82981750dbc4f3dcd1b8a81c02e8e131.js"></script>  
  
배열을 쓸 생각이었는데... vector? 그리고 class? public? '&' 기호는 또 뭐죠?  
알고리즘을 생각하기 전, 이 부분들부터 하나하나 짚고 넘어가겠습니다.  
  
1. class  
c++은 완전 객체지향 언어는 아니지만, 객체지향을 지원합니다.  
간단하게 설명하자면, class를 사용해도 되고, class 없이 function만으로도 실행 가능합니다.  
LeetCode에선 채점 편의상 모든 c++ 풀이를 Solution이라는 class 내에서 작성하도록 합니다.  
그러니 우리는, 앞으로 class는 신경쓰지 않고 그 내부의 함수에서만 코드를 작성하면 됩니다.
  
2. public  
클래스의 멤버 함수가 외부에서 접근 가능하도록 만들어주는 접근 지정자입니다.  
이것도 우리가 관여할 부분은 아니기에, 앞으로 신경쓸 필요 없겠습니다.
  
3. vector  
싱글벙글 배열 생각을 하고 들어왔는데, 당황스럽습니다.  
vector는 STL(c++ 표준 라이브러리)에서 제공하는 자료구조로, 동적 배열이라 보시면 됩니다.  
기존 배열과의 차이점을 표로 정리해보겠습니다.  
  
| | Array | Vector |
| --- | --- | --- |
| **크기** | 선언 시 고정 | 가변 |
| **메모리 할당** | 스택(기본) 또는 힙 | 힙 |
| **초기화** | {}로만 가능 | {} 또는 resize, assign |
| **크기 확인** | sizeof(arr)/sizeof(arr[0]) | .size() |
| **삽입/삭제** | 불가능 | .push_back(), .pop_back() |
| **범위 체크** | 불가능 | .at() |
| **헤더** | 필요 없음 | #include<vector> |
  
그러니까, #include<vector>만 한다면, 배열에선 일일이 구현해야 했던 기능들을  
vector에선 다양한 method를 사용해 빠르게 해낼 수 있다는 거죠.  
그러니 우리도 앞으로 c++에선 최대한 배열 대신 vector를 사용하도록 하겠습니다!  
  
4. &  
거두절미하고, 표를 먼저 보시죠.
  
| 함수 인자 | 의미 | 특징 |
| --- | --- | --- |
| **vector<int> nums** | value 전달 | 벡터 복사해 느림, 원본 안 바뀜 |
| **vector<int>& nums** | reference 전달 | 복사 없어 빠름, 원본 바뀜 |
| **const vector<int>& nums** | const reference 전달 | 복사 없어 빠름, 원본 수정 불가 |
  
자주 사용하는 형태의 인자들을 정리해 봤습니다.  
원본 벡터는 그대로 유지한 채 복사해서 작업해야 할 경우 첫 번째 형태를,  
원본 벡터를 바꿔도 되는 경우는 빠른 두 번째 형태를,  
원본 벡터는 그대로 유지한 채 값만 참조하는 경우는 안전한 세 번째 형태를 사용합니다.  
  
Two Sum 문제에선 원본 벡터를 유지할 필요가 없으니 이 중 두 번째를 사용한 것이죠.  
  
자 그럼 이제, 문제를 풀 준비가 되었습니다. 알고리즘을 생각해 볼까요?  
  
두 가지 수를 뽑는 모든 경우를 수행하다 보면 문제가 풀리지 않을까요?  
nums = [2, 7, 11, 15], target = 26인 경우,  
2 + 7 = 9  
2 + 11 = 13  
2 + 15 = 17  
7 + 11 = 18  
7 + 15 = 22  
11 + 15 = 26이니  
[2, 3]을 return하면 되는 것이죠.  
  
O(n^2)으로 수행 가능하고, (여기서 n은 nums 배열의 길이입니다.)  
n은 최대 10^4이라고 했으니, 1초 안에 해결 가능합니다.  
  
하지만 이런 제 생각을 읽은 것인지, Follow-up에서 O(n^2) 밑으로 시도해보라네요.  
어떻게 하면 될까요?  
  
만약 nums 벡터가 정렬돼 있다면, 좀 더 빠를 것 같습니다.  
nums = [1, 2, 4, 8, 16, 32], target = 36인 경우를 생각해 보죠.  
1 + ? = 36  
-> 벡터에 35가 존재하는지 찾습니다. 여기서 정렬되면 좋은 이유가 나오는데,  
정렬되지 않은 벡터에서 탐색은 O(n)이 걸리지만, 정렬된 벡터에서는 O(logn)이거든요.  
2 + ? = 36  
-> O(logn)  
...  
16 + ? = 36
-> O(logn)  
  
이런식으로 모든 원소에 대해 target을 만드는 나머지 짝을 탐색하다 보면, 답을 찾는 겁니다.  
예제에선 4에서 짝을 찾아 끝났겠지만, 최악의 경우를 가정하고 끝까지 적어 봤습니다.  
n개의 원소에 대해 O(logn)의 탐색을 진행하므로, 시간복잡도는 O(nlogn)이네요.  
그런데 이건 '정렬된 벡터'에서의 경우죠? 벡터 정렬에는 시간복잡도가 얼마나 걸릴까요?  
네, 정렬 역시 O(nlogn)이 소요됩니다.  
정렬이 끝난 이후 탐색을 진행하면 되므로, O(nlogn + nlogn) = O(nlogn)입니다.  
O(n^2)보다 빠르게 가능하네요!  
  
그런데 사실... O(nlogn)보다도 빠르게 구현이 가능합니다.  
바로, HashMap(unordered_map)을 사용하면 됩니다!  
  
HashMap이란, (key, value) 쌍으로 데이터를 저장하는 자료구조입니다.  
unordered_map은 STL에서 HashMap을 구현한 컨테이너의 이름이구요.  
HashMap의 특징은 아래 표를 참고하시면 되겠습니다.  
  
| 자료구조 | 메모리 구조 | 탐색 속도 | 메모리 | 순서 |
| --- | --- | --- | --- | --- |
| **vector** | 연속된 메모리 블럭 | O(n) | 작음(데이터 수) | 있음 |
| **map** | red-black tree | O(logn) | 매우 큼(노드마다 데이터 외 오버헤드 발생) | 정렬 |
| **unordered_map** | hash table + bucket array | O(1) | 큼(데이터 수 1.5 ~ 2배) | 없음 |
  
정리하자면,  
메모리를 아끼고 싶다면 vector를,  
정렬된 상태가 중요하다면 map을,  
빠른 탐색/삽입/삭제가 중요하다면 unordered_map을 사용합니다.  
  
우린 지금 시간복잡도를 줄이고 싶으니 unordered_map을 사용해보자는 것이죠.  




  
그럼 다음 포스팅에서 LeetCode 2번 문제와 함께 만나뵙겠습니다!
