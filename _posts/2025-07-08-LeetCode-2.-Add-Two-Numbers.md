---
title: "[리트코드] 2. Add Two Numbers"
excerpt: "리트코드 2번 문제입니다."

categories:
  - leetcode
tags:
  - [algorithm, leetcode]

permalink: /leetcode/2025-07-08-LeetCode-2.-Add-Two-Numbers/

toc: true
toc_sticky: true

date: 2025-07-08
last_modified_at: 2025-07-08
---

## 🦥 본문

안녕하세요, 오늘 만나볼 문제는 리트코드 2번 문제, Add Two Numbers입니다.  
바로 문제 만나보시죠!  
  
[Add Two Numbers - LeetCode](https://leetcode.com/problems/add-two-numbers/)  
  
요약하자면, 자릿수가 거꾸로 저장된 두 수의 합을 반환하되,  
역시 자릿수를 거꾸로 하여 반환하라는 것이네요.  
그리고 스켈레톤 코드 윗부분에 주석이 달려있네요.  
  
<script src="https://gist.github.com/redjo99/7061660754756a61ee79551f0eabb7a3.js"></script>  
  
linked list의 구조체를 정의해 주었네요.  
ListNode 구조체를 한번 살펴보고 넘어갑시다.  
  
우선, ListNode는 값(val)과 다음 노드의 포인터(next)를 멤버로 가집니다.  
linked list니 그렇겠죠?  
  
생성자는 세 가지가 있네요.  
인자가 없으면 val = 0, 다음 노드는 지정하지 않는 노드를 생성합니다.  
인자가 x 하나라면 val = x, 역시 다음 노드는 지정하지 않습니다.  
인자가 x와 next 2개라면 val = x, 다음 노드는 next 노드로 설정됩니다.  
  
그럼 이 구조체를 어떻게 사용 가능할까요?  
순서대로 하나하나 살펴봅시다.  
  
1. 생성 및 연결  
5 -> 0 -> 3 리스트를 만들어보겠습니다.  
  
1)  
ListNode* node2 = new ListNode();   // 값이 0인 노드 node2 생성.  
ListNode* node3 = new ListNode(3);   // 값이 3인 노드 node3 생성.  
ListNode* node1 = new ListNode(5, &node2);   // 값이 5인 node1을 생성하고, node2 앞에 붙임.  
node2->next = node3;   // node2 뒤에 node3를 붙임.
  
2)  
ListNode* node1 = new ListNode(5);  
node1->next = new ListNode(0);   // 5 뒤에 0 붙임.   
node1->next->next = new ListNode(3);   // 5 뒤의 뒤에 3 붙임.  
  
이런 식으로 여러 가지 방법이 있습니다.  
  
참고로, 지금은 함수 내부 작업이라 언급하지 않았지만  
new는 동적 메모리 할당입니다.  
따라서 함수 외부 코드까지 작업하실 때는 메모리 해제가 필요하며,  
linked list의 맨 뒤에서부터 역순으로 delete를 실행하면 됩니다.  
바로 위의 예시에선,  
delete node1->next->next;  
delete node1->next;  
delete node1;  
순서로 실행하시면 됩니다.  
  
2. 중간에 삽입  
5 -> 0 -> 3 리스트가 생성된 상태에서,  
4를 중간에 삽입해 5 -> 4 -> 0 -> 3으로 만들어봅시다.  








  
자 그럼 이제, 문제를 풀 준비가 되었습니다. 알고리즘을 생각해 볼까요?  
  
두 가지 수를 뽑는 모든 경우를 수행하다 보면 문제가 풀리지 않을까요?  
nums = [2, 7, 11, 15], target = 26인 경우,  
2 + 7 = 9  
2 + 11 = 13  
2 + 15 = 17  
7 + 11 = 18  
7 + 15 = 22  
11 + 15 = 26이니  
[2, 3]을 return하면 되는 것이죠.  
  
O(n^2)으로 수행 가능하고, (여기서 n은 nums 배열의 길이입니다.)  
n은 최대 10^4이라고 했으니, 1초 안에 해결 가능합니다.  
  
하지만 이런 제 생각을 읽은 것인지, Follow-up에서 O(n^2) 밑으로 시도해보라네요.  
어떻게 하면 될까요?  
  
만약 nums 벡터가 정렬돼 있다면, 좀 더 빠를 것 같습니다.  
nums = [1, 2, 4, 8, 16, 32], target = 36인 경우를 생각해 보죠.  
1 + ? = 36  
-> 벡터에 35가 존재하는지 찾습니다. 여기서 정렬되면 좋은 이유가 나오는데,  
정렬되지 않은 벡터에서 탐색은 O(n)이 걸리지만, 정렬된 벡터에서는 O(logn)이거든요.  
2 + ? = 36  
-> O(logn)  
...  
16 + ? = 36
-> O(logn)  
  
이런식으로 모든 원소에 대해 target을 만드는 나머지 짝을 탐색하다 보면, 답을 찾는 겁니다.  
예제에선 4에서 짝을 찾아 끝났겠지만, 최악의 경우를 가정하고 끝까지 적어 봤습니다.  
n개의 원소에 대해 O(logn)의 탐색을 진행하므로, 시간복잡도는 O(nlogn)이네요.  
그런데 이건 '정렬된 벡터'에서의 경우죠? 벡터 정렬에는 시간복잡도가 얼마나 걸릴까요?  
네, 정렬 역시 O(nlogn)이 소요됩니다.  
정렬이 끝난 이후 탐색을 진행하면 되므로, O(nlogn + nlogn) = O(nlogn)입니다.  
O(n^2)보다 빠르게 가능하네요!  
  
그런데 사실... O(nlogn)보다도 빠르게 구현이 가능합니다.  
바로, HashMap(unordered_map)을 사용하면 됩니다!  
  
HashMap이란, (key, value) 쌍으로 데이터를 저장하는 자료구조입니다.  
unordered_map은 STL에서 HashMap을 구현한 컨테이너의 이름이구요.  
HashMap의 특징은 아래 표를 참고하시면 되겠습니다.  
  
| 자료구조 | 메모리 구조 | 탐색 속도 | 메모리 | 순서 |
| --- | --- | --- | --- | --- |
| **vector** | 연속된 메모리 블럭 | O(n) | 작음(데이터 수) | 있음 |
| **map** | red-black tree | O(logn) | 매우 큼(노드마다 데이터 외 오버헤드 발생) | 정렬 |
| **unordered_map** | hash table + bucket array | O(1) | 큼(데이터 수 1.5 ~ 2배) | 없음 |
  
정리하자면,  
메모리를 아끼고 싶다면 vector를,  
정렬된 상태가 중요하다면 map을,  
빠른 탐색/삽입/삭제가 중요하다면 unordered_map을 사용합니다.  
  
우린 지금 시간복잡도를 줄이고 싶으니 unordered_map을 사용해보자는 것이죠.  
unordered_map 사용법을 알아본 뒤, 문제로 넘어가겠습니다.  
  
1. 선언
unordered_map<int, int> m;  
key가 int, value가 int 형태인 HashMap m을 선언합니다.  
   
2. 삽입  
삽입에는 여러 가지 방법이 있습니다.
key가 10, value가 100인 항목을 삽입한다면,  
m[10] = 100;  
m.insert({10, 100});  
m.insert(make_pair(10, 100));  
등 다양한 방법 중 편한 걸 사용하시면 됩니다.  
  
3. key 존재여부 확인  
unordered_map의 count 메서드는 key가 있으면 1, 없으면 0을 반환합니다.
m에 key 20이 존재하는지 확인하려면,
m.count(20) 을 활용하시면 됩니다.  
  
4. 값 변경  
m[10] = 777;  
위 코드처럼 기존에 있던 key에 대해 다른 value를 할당하면,  
덮어쓰기가 수행됩니다.  
다만, insert 메서드는 덮어쓰기가 불가능하니 주의하시길 바랍니다!
m.insert({10, 777});   // 이 문장은 무시됩니다.  
  
5. 삭제  
erase 메서드를 사용하면 됩니다.  
m.erase(10);   // key가 10인 항목을 제거합니다.  
  
6. 모든 항목 출력  
마지막으로 반복문을 통해 unordered_map의 모든 항목을 출력해 봅시다.  
마지막에 소개드리는 이유가 있으니, 잘 보세요!  
  
for (auto [key, val] : m) {
  cout << key << " " << val << endl;
}  
  
생소한 형태의 for문이죠?  
우선 : m 부분부터 설명하자면, for문에서 m을 순회한다는 뜻입니다.  
  
다음으로 auto에 대해 소개드리자면, 변수 타입을 자동으로 추론하는 키워드입니다.  
c++엔 복잡한 타입이 많다 보니, 직접 쓰기도 귀찮고 실수도 일어나기 쉽습니다.  
그래서 컴파일러가 알아서 타입을 유추하게 했답니다.  
사용법은 아래와 같습니다.  
auto x = 5;   // x는 int  
auto y = 1.23;   // y는 double  
vector<int> v = {0, 1, 2};  
auto it = v.begin();   // it은 vector<int>::iterator  
  
만약 위의 for문에서 auto를 사용하지 않았더라면, 아래의 형태로 작성해야 합니다.  
for(pair<const int, int> p : m) {  
  int key = p.first;  
  int val = p.second;  
  cout << key << " " << val << endl;  
}  
  
복잡하죠? 이래서 auto를 사용하는 거랍니다!  
그럼 이제 진짜 문제로 넘어가 봅시다. 긴 글 따라오느라 고생하셨습니다..ㅎㅎ  
  
방법은 앞에서 제가 설명했던 O(nlogn) 아이디어와 비슷합니다.  
각 원소에 대해 target을 만드는 짝(complement)을 찾는 겁니다.  
unordered_map에선 탐색이 O(1)이고, 정렬도 필요없으니 훨씬 빨라지는 것이죠.  
코드 확인해 보시죠!  
  
<script src="https://gist.github.com/redjo99/d7a3a9ceec3058ef872554a48e37f1d3.js"></script>  
  
짧지만 이해가 쉽지 않으니, 예시를 통해 for문의 동작방식을 살펴보겠습니다.  
nums = [2, 7, 11, 15], target = 22인 경우,  
  
1. i = 0  
nums[0] = 2 이므로 complement = target - nums[0] = 20 입니다.  
현재 HashMap m에는 20이라는 key가 없으므로, (HashMap이 비어있으니 당연합니다.)  
m.count(20) = 0 이고, if문 내부는 실행되지 않습니다.  
대신 밑에 있는 m[2] = 0 이 실행되어, m = {2: 0} 이 됩니다.  
  
2. i = 1  
nums[1] = 7 -> complement = 15  
m에 key 15가 없으므로, 이번에도 if문은 넘어갑니다.  
m[7] = 1 -> m = {2: 0, 7: 1}  
  
3. i = 2  
nums[2] = 11 -> complement = 11  
m에 key 11이 없으므로, if문 pass.  
m[11] = 2 -> m = {2: 0, 7: 1, 11: 2}  
  
4. i = 3  
nums[3] = 15 -> complement = 7  
m에 key 7이 존재합니다! 드디어 if문 내부로 들어갑니다.  
key는 7, 현재 i는 3이므로 {m[7], 3}을 return합니다.
  
결국 [1, 3]이라는 답을 얻어내는 것이죠.  
  
nums 첫 번째 원소부터 순차적으로 탐색하기 때문에,  
{m[complement], i}에서 i는 m[complement]보다 큰 값일 수밖에 없습니다.  
i보다 큰 index를 가진 nums 원소들은 m에도 존재하지 않으니까요.  
따라서 [3, 1]처럼 순서가 역전된 값을 반환할 걱정도 없고, 정답이 되겠습니다!  
  
실제로 채점 결과 정답이었고, 아래의 결과를 얻었습니다.  
  
|  | Runtime | Memory |
| --- | --- | --- |
| **Result** | 1ms | 14.76MB |
| **Beats** | 80.14% | 51.13% |
  
참고로, Beats는 몇 퍼센트의 제출보다 좋은 결과를 얻었는지에 대한 수치입니다.  
제 경우 시간에서 상위 20%, 메모리에서 상위 50%의 기록인 거죠.  
예상했던 대로 시간에서 우수한 성능, 메모리에선 평균적인 성능이 나왔습니다.  
  
코드 길이는 짧았지만, 많은 요소를 생각해야 하는 좋은 문제였네요.  
  
그럼 다음 포스팅에서 LeetCode 2번 문제와 함께 만나뵙겠습니다!
