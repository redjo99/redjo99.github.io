---
title: "[Brute Force] 오목"
excerpt: "오목 문제를 열심히 구현해봅시다."

categories:
  - bruteforce
tags:
  - [algorithm, bruteforce]

permalink: /bruteforce/2025-06-22-brute-force-오목/

toc: true
toc_sticky: true

date: 2025-06-22
last_modified_at: 2025-06-24
---

## 🦥 본문

Brute Force의 세 번째 문제로는,
오목 문제를 가져왔습니다.

실제 오목처럼 경우의 수가 아주 많아 그만큼 구현이 복잡하고,  
백준에서의 정답률도 매우 낮은 편입니다.
하지만 저번 문제처럼 다른 알고리즘이 섞이는 경우는 없습니다. 그럼 문제 보시죠!  
  
[오목 - 백준](https://www.acmicpc.net/problem/2615)  
  
다행히도 진짜 오목을 두라는 건 아니었네요.  
완료된 판에서 승부만 판단하면 되니, 오목이 완성되는 경우만 잘 따져보면 되겠습니다!  
자 그럼 풀어보시고, 아래 제 코드 보시죠! (정답은 맨 아래에)  
  
<script src="https://gist.github.com/redjo99/08de12fe590a590a780ec4e61234a15d.js"></script>  
  
모든 칸에 대해, 대각 방향/가로 방향/세로 방향, 각각 흑돌 오목/백돌 오목을 판별하도록,  
총 19*19 칸에 대해 6가지 검사를 시행하도록 했습니다.  
예를 들자면 이런 거죠.  
  
  '(6, 3) 칸에서 흑돌의 세로 방향 오목이 시작됐나?'  
= '(6, 3), (7, 3), (8, 3), (9, 3), (10, 3) 값은 1이고, (5, 3), (11, 3) 값은 1이 아닌가?'  
  
  그런데 8%에서 오답 판별이 났습니다. 뭐가 문제였을까요?  
바로....  
  
  대각 방향 검사에서 오른쪽 대각만 검사하고, 왼쪽 대각을 놓쳤기 때문이죠.  
저도 주석을 달다가 캐치했는데, 주석의 중요성을 알 수 있었네요..ㅎㅎ  
왼쪽 대각의 경우도 추가해 주었습니다.  
  
<script src="https://gist.github.com/redjo99/6f38393a682c64f439126afeab8fa910.js"></script>  
  
왼쪽 대각은 검사할 때, 왼쪽으로 내려가게 됩니다.  
저는 칸이 있는지 검사하는 로직을 추가하기보단 배열을 조금 늘리는 게 낫다고 판단했기에,  
보드 배열 크기를 조금 키웠습니다.  
그리고 제 반복문에선 5번 칸부터 검사하지만, 출력은 1번 칸부터 이루어져야 하므로  
i와 j에 4를 뺀 값들을 각각 출력하도록 조정했습니다.  
다만, 왼대각 방향에서는 마지막 돌이 가장 왼쪽에 있으므로 해당 돌을 출력하도록 했습니다.  
  
  이렇게 조정하니 결국 정답을 얻어냈습니다.  
세세히 조건을 맞춰야 하는 부분이 많았던 문제였네요.  
  
그럼 다음 포스팅에서 새로운 Brute Force 예제와 함께 만나요!

