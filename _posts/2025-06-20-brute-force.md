---
title: "[Brute Force] 소개 및 기초문제"
excerpt: "모든 알고리즘의 기초가 되는 브루트 포스와 완전탐색을 소개합니다."

categories:
  - bruteforce
tags:
  - [algorithm, bruteforce]

permalink: /bruteforce/2025-06-20-brute_force/

toc: true
toc_sticky: true

date: 2025-06-20
last_modified_at: 2025-06-21
---

## 🦥 본문

알고리즘 공부의 시작으로 Brute Force(브루트 포스)를 소개드리는 이유는,  
모든 알고리즘의 기초가 되는 방식이기 때문입니다.  
  
그런데 여러분은 '완전탐색'이라는 알고리즘 또한 들어보셨을 수도 있습니다.  
차례대로 설명드리면서 차이를 알려드리겠습니다.  
  
먼저 Brute Force 알고리즘은, 문제해결을 위해 모든 경우를 탐색하여 해답을 얻습니다.  
완전탐색 알고리즘은, 모든 경우를 탐색하는 방식 자체를 말합니다.  
따라서 둘의 차이는, 탐색에 중점을 두느냐 해답 찾기에 중점을 두느냐에 있습니다.  
저는 알고리즘 문제풀이에 중점을 두므로, 앞으로는 Brute Force라는 용어만 사용하겠습니다.  
  
Brute Force는 모든 경우를 탐색하므로, 해답 찾기에 실패할 걱정은 없습니다.  
코드 작성 또한 별도의 번뜩이는 아이디어가 필요하지 않으므로, 다른 알고리즘에 비해 편하죠.  
다만, 모든 경우를 탐색하기 때문에, 시간 복잡도가 높습니다.  
실제로 앞으로 배울 다른 알고리즘들은 시간 단축을 위해 만들어졌기 때문에,  
어떻게 보면 Brute Force를 피하기 위해 만들어졌다고 볼 수도 있습니다.  
  
따라서 여러분이 앞으로 복잡한 문제를 만나신다면,  
1. 이거 Brute Force로 시간 내에 풀 수 있을까..?
2. (안 된다고 판단한 후) 그럼 무슨 알고리즘을 적용해야 할까..?  
  
순서로 생각하셔도 무방합니다.  
  
자, 그럼 이번에도 간단한 문제를 만나보겠습니다.  
  
[숫자 야구 - 백준](https://www.acmicpc.net/problem/2503)  
  
요약하자면 숫자야구 문답이 입력으로 주어지고, 가능한 답의 개수를 출력해야 합니다.  
링크에 있는 예시 입출력을 살펴보죠.  
  
먼저 2 스트라이크 0 볼을 기록한 327부터 보겠습니다.  
셋 중 하나겠죠.  
1. 32X (X != 7)
2. 3X7 (X != 2)
3. X27 (X != 3)
  
그리고 1 스트라이크 0 볼을 기록한 356도 동시에 보겠습니다.  
이것도 셋 중 하나겠죠.  
1. 3XY (X != 5 && Y != 6)
2. X5Y (X != 3 && Y != 6)
3. XY6 (X != 3 && Y != 5)
  
32X, 3X7, X27 중 하나를 만족하면서, 동시에 3XX, X5X, XX6 중 하나도 만족해야 하네요.  
이건 32X, 3X7 두 가지로 볼 수 있습니다.  
(X5X와 XX6은 각각 3X7, 32X에 포함되므로 따로 세지 않았습니다.)  
  
이제 1 스트라이크 1 볼을 기록한 123을 보겠습니다.  
32X, 3X7 중 해당 조건을 만족하는 건 무엇일까요?  
32X (X != 7 && X != 1) 밖에 없겠습니다.  
(321이라면 1 스트라이크 2 볼이 되므로 X가 1이 아니라는 조건이 추가됐으며,  
3X7이 불가능한 이유는 X가 2가 아니라는 조건이 있었기에 0 스트라이크 1 볼이 되기 때문입니다.)  
  
자, 그럼 마지막 0 스트라이크 1 볼을 기록한 489를 봅시다.  
32X가 해당 조건을 만족하려면, X가 4 또는 X가 9이면 되겠습니다.  
  
따라서, 가능한 답은 324와 328 두 가지이므로, 2를 출력하면 됩니다!  


  자 좋습니다. 이제 문제는 이해했는데, 어떤 알고리즘으로 풀면 될까요?  
제가 예시를 풀었던 대로 하면 될까요?  
2 스트라이크인 경우를 찾아서 세 가지 경우로 나누고,  
아 그전에 2 스트라이크인 경우가 없다면 1 스트라이크부터 세 가지 경우로 나누고,  
아 그런데 3 스트라이크가 있었다면 3 스트라이크 그대로 답이니까 1을 출력하고,  
....  
  
입력이 다양할 수 있기 때문에 복잡하죠?  
우리가 앞에서 얘기한 순서대로 생각해봅시다!  
바로 'Brute Force로 시간 내에 가능할까?'입니다.  
  
문제에서 시간 제한을 1초로 뒀는데, 통상 1억(10^8)번의 연산에 1초가 소요됩니다.  
지금은 컴퓨터가 조항져 2억5천~3억번까지도 가능하다고 하는데,  
저희는 넉넉하게 1억 번 내의 연산으로 수행해봅시다.  
  
이 문제에서 Brute Force란,  
모든 숫자야구 조합에 대해 문답 조건들을 다 만족하는지 테스트한 다음,  
해당하는 숫자야구 조합 개수를 출력하는 거겠네요.  
  
그럼 시간복잡도를 파악해 봅시다.  
첫 번째 숫자 9가지, 두 번째 숫자 8가지, 세 번째 숫자 7가지가 있으므로  
총 504가지 숫자야구 조합이 있습니다.  
  
그리고 각 조합에 대해 문답 개수 N만큼 테스트를 해야 하는데,  
문제 조건을 보면 N은 최대 100까지 가능하네요.  
따라서 총 50,400번의 테스트 끝에 우리는 답을 얻어낼 수 있습니다.  
  
50,400이면 1억보다 매우 작은 수이므로 충분히 시간 안에 풀 수 있겠죠?  
따라서 우리는 복잡한 알고리즘을 고민하기보단, Brute Force를 적용하면 되겠습니다.  
  
  
그럼 자유롭게 풀어 보시고, 이후 아래의 제 코드를 참고하시죠!  
(정답만 보실 분들은 맨 아래로 내리시면 됩니다.)  
  
  
<script src="https://gist.github.com/redjo99/ab5c94e0572ff25951243545c7354802.js"></script>  
  
백준 채점 3퍼센트에서 막혔습니다. 저도 한번만에 풀지 못했네요.  
원래 알고리즘 문제를 풀 때 반례 찾는 것도 중요하니, 함께 찾아보죠.  
위 코드는 뭐가 문제였을까요?  
정답은...  
  
모든 숫자야구 조합에 대해 검사할 때(line 15), 987을 빼놓고 검사했기 때문입니다.  
자 그럼 아래 코드처럼 987에 등호를 포함시켜 검사해 보죠!  
  
<script src="https://gist.github.com/redjo99/650e7eada9c148a54b9643c70b279719.js"></script>  
  
이번엔 18퍼센트에서 막혔네요. 이번 원인도 한번 찾아보시죠!  
정답은...  
  네, 그냥 배열 크기가 부족해서 그런 거였네요.  
코드 짤 때 N을 10 이하로 잘못봐서.. 배열 크기를 13이 아닌 103으로 선언해야 맞겠죠?^^  
(참고로 저는 out of index 에러를 방지하기 위해 배열 크기에 3 정도 여유를 두는 편입니다.)  
  
반례가 뭘까 한 시간을 고민했는데.. 여러분은 문제 조건을 잘 보시기 바랍니다ㅠㅠ  
어쨌든 최종 정답 코드는 아래와 같습니다.  
  
<script src="https://gist.github.com/redjo99/d345f2019b620f6c1936f181412336ca.js"></script>  
  
  
그럼 다음 포스팅에서 새로운 Brute Force 예제와 함께 만나요!
