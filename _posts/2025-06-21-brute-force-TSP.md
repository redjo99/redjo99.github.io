---
title: "[Brute Force] 외판원 순회"
excerpt: "CS 분야에서 널리 쓰이는 외판원 순회(TSP) 문제를 풀어봅시다."

categories:
  - bruteforce
tags:
  - [algorithm, bruteforce, TSP]

permalink: /bruteforce/2025-06-21-brute-force-TSP/

toc: true
toc_sticky: true

date: 2025-06-21
last_modified_at: 2025-06-22
---

## 🦥 본문

Brute Force의 두 번째 문제로는,
외판원 순회(TSP) 문제를 가져왔습니다.

TSP는 computer science 분야에서 아주 중요하게 취급되므로,  
오늘 처음 들어보셨다면 이번 기회를 통해 접해보시길 바랍니다.  
  
사실 TSP 문제는 구성과 조건에 따라 어떤 알고리즘으로 풀어야 하는지가 달라집니다.  
제가 들고 온 TSP 문제는 Brute Force로 풀 수 있는 것이니, 함께 문제를 보시죠!  
  
[외판원 순회 2 - 백준](https://www.acmicpc.net/problem/10971)  
  
예제의 지도를 그려보자면, 아래와 같이 되겠네요.  
  
![tsp2 map](/assets/images/posts_img/TSP2_baekjoon.png)
  
이 문제는 우리가 답을 찾을 때도 머릿속에서 모든 순회 경우의 경로 합을 계산하며,  
그 중 가장 작은 값을 답으로 정한다는 것을 알 수 있습니다.  
따라서 고민없이 Brute Force를 적용하면 된다는 건데요,  
혹시 모르니 시간복잡도 계산부터 해 봅시다!  
  
  도시의 수가 N일 때, 출발점을 정하는 경우는 N 입니다.  
이후 하나의 출발점에서 다음 지점으로 갈 수 있는 경우의 수는 N - 1 입니다.  
마찬가지로 다음 지점은 N - 2, 그 다음은 N - 3, ... 이므로,  
총 경로의 수는 N! 이라 할 수 있겠네요.  
매번 최솟값을 갱신해야 하지만, 비교 연산 하나면 해결되므로 이는 O(1) 입니다.  
따라서 시간복잡도는 O(N! * 1) = O(N!) 이 되고,  
최악의 경우 N = 10일 때이므로 10! 회의 연산이 필요하네요.  
지난 포스팅에서 10^8 이하면 1초 안에 해결이 가능하다고 했죠?  
10!은 10^8보다 현저히 작은 값이고, 시간 제한도 2초이므로 Brute Force로 풀면 되겠습니다.  

  그럼 이번에도 자유롭게 풀어 보시고, 아래의 제 코드를 참고하시죠!  
(이번에도 정답은 맨 아래에)  
  
<script src="https://gist.github.com/redjo99/5809ae0ea954d98cbaf42362aec92b90.js"></script>  
![tsp2 starting test](/assets/images/posts_img/tsp2_starting_test.png)  
  
  우선 입력을 정상적으로 받는지, 초기 출발점과 도착점이 정상적으로 설정되는지 테스트했습니다.  
출력을 보아 문제 없으므로 코드 작성을 이어갔습니다.  
  
<script src="https://gist.github.com/redjo99/4363fba7d821026b0e1608d1a979bf71.js"></script>  
  
재귀함수 기법을 써서(여기선 백트래킹을 사용했는데, 이에 대해서는 백트래킹 파트에서 설명하겠습니다.)  
풀어봤는데, 예제에 대해 21이라는 오답이 나왔습니다.  
  
원인을 파악하기 위해 중간중간 출력을 넣어 확인하겠습니다.  
코드에서 dist 값에 w[x][i]를 더하거나 뺄 때마다, w[x][i] 값을 출력해 봤습니다.  
  
![tsp2 debug 1](/assets/images/posts_img/tsp2_1.png)  
    
위에 제가 그려놓은 지도 그림과 함께 보시면 이해가 쉬울 겁니다.  
처음에는 1에서 2로 출발하므로, plus 10이 맞죠.  
그런데.. plus 5? 아하, 원인을 파악했습니다.  
모든 정점을 탐방해야만 처음 정점으로 돌아갈 수 있는데, 그 조건이 없어 중간에 돌아가 버렸네요.  
그러면 이를 수정해 보겠습니다!  
  
<script src="https://gist.github.com/redjo99/c09331fe9e1e8bf466ff4ce8aa05f686.js"></script>  
  
방문하지 않은 간선이더라도, 방문했던 정점으로 중간에 되돌아가선 안됩니다.  
이를 위해, visit 배열을 간선에 대한 것이 아닌 정점에 대해 적용하기 위해 일차원 배열로 바꿨습니다.  
예제 결과도 35로 잘 나왔습니다. 그런데.. 실행했더니 5%에서 틀렸습니다!  
이번엔 뭐가 문제일까요? 바로...  
  
  0은 갈 수 없는 경우를 의미한다는 걸 생각하지 않았기 때문입니다!  
예를 들어 볼까요? 1 -> 2 간선의 weight를 10에서 0으로 바꿔보겠습니다. 아래의 그림을 보시죠.  
  
![tsp2 map 2](/assets/images/posts_img/TSP2_baekjoon_2.png)  
  
  정확한 알고리즘이라면, 1에서 출발할 때 2번 간선으로는 갈 수 없으니 3번부터 방문해야 합니다.  
하지만 지금 제 알고리즘은 그냥 방문해 버리겠죠.  
심지어 dist 계산 시 더할 것도 없으니, 최솟값에 큰 영향을 미치게 됩니다.  
자 그럼, 다시 수정해 봅시다.  
  
<script src="https://gist.github.com/redjo99/eeb009daef04ce720d57a122ecadfa7a.js"></script>  
  
방문하지 않은, 그리고 '방문할 수 있는' 정점에 대해서만 방문하도록 line 31에 조건을 추가했습니다.  
몇몇 세세한 부분들도 추가로 수정했습니다.  그러나, 이번엔 35%에서 막히는군요.  


그럼 다음 포스팅에서 새로운 Brute Force 예제와 함께 만나요!
