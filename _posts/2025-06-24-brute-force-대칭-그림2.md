---
title: "[Brute Force] 대칭 그림2"
excerpt: "고난이도의 Brute Force 문제에 도전해봅시다."

categories:
  - bruteforce
tags:
  - [algorithm, bruteforce]

permalink: /bruteforce/2025-06-24-brute-force-대칭-그림2/

toc: true
toc_sticky: true

date: 2025-06-24
last_modified_at: 2025-06-24
---

## 🦥 본문

Brute Force의 마지막 문제로, 다이아 난이도의 문제를 가져왔습니다.
  
이번 문제로 Brute Force를 마스터한 다음, 다음 알고리즘으로 넘어가겠습니다! 문제 보시죠~  
  
[대칭 그림2 - 백준](https://www.acmicpc.net/problem/2334)  
  
  
자 그럼 풀어보시고, 아래 제 코드 보시죠! (정답은 맨 아래에)  
  
<script src="https://gist.github.com/redjo99/08de12fe590a590a780ec4e61234a15d.js"></script>  
  
모든 칸에 대해, 대각 방향/가로 방향/세로 방향, 각각 흑돌 오목/백돌 오목을 판별하도록,  
총 19*19 칸에 대해 6가지 검사를 시행하도록 했습니다.  
예를 들자면 이런 거죠.  
  
  '(6, 3) 칸에서 흑돌의 세로 방향 오목이 시작됐나?'  
= '(6, 3), (7, 3), (8, 3), (9, 3), (10, 3) 값은 1이고, (5, 3), (11, 3) 값은 1이 아닌가?'  
  
  그런데 8%에서 오답 판별이 났습니다. 뭐가 문제였을까요?  
바로....  
  
  대각 방향 검사에서 오른쪽 대각만 검사하고, 왼쪽 대각을 놓쳤기 때문이죠.  
저도 주석을 달다가 캐치했는데, 주석의 중요성을 알 수 있었네요..ㅎㅎ  
왼쪽 대각의 경우도 추가해 주었습니다.  
  
<script src="https://gist.github.com/redjo99/6f38393a682c64f439126afeab8fa910.js"></script>  
  
왼쪽 대각은 검사할 때, 왼쪽으로 내려가게 됩니다.  
저는 칸이 있는지 검사하는 로직을 추가하기보단 배열을 조금 늘리는 게 낫다고 판단했기에,  
보드 배열 크기를 조금 키웠습니다.  
그리고 제 반복문에선 5번 칸부터 검사하지만, 출력은 1번 칸부터 이루어져야 하므로  
i와 j에 4를 뺀 값들을 각각 출력하도록 조정했습니다.  
다만, 왼대각 방향에서는 마지막 돌이 가장 왼쪽에 있으므로 해당 돌을 출력하도록 했습니다.  
  
  이렇게 조정하니 결국 정답을 얻어냈습니다.  
세세히 조건을 맞춰야 하는 부분이 많았던 문제였네요.  
  
그럼 다음 포스팅에서 새로운 Brute Force 예제와 함께 만나요!

